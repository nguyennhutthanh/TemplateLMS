{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"E:\\\\ReactJS\\\\project-cursus\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar generate = require('regjsgen').generate;\n\nvar parse = require('regjsparser').parse;\n\nvar regenerate = require('regenerate');\n\nvar unicodeMatchProperty = require('unicode-match-property-ecmascript');\n\nvar unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nvar iuMappings = require('./data/iu-mappings.js');\n\nvar ESCAPE_SETS = require('./data/character-class-escape-sets.js'); // Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\n\n\nvar UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\n\nvar BMP_SET = regenerate().addRange(0x0, 0xFFFF); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\n\nvar DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A, // Line Feed <LF>\n0x000D, // Carriage Return <CR>\n0x2028, // Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\nvar getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n\n  return ESCAPE_SETS.REGULAR.get(character);\n};\n\nvar getUnicodeDotSet = function getUnicodeDotSet(dotAll) {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nvar getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {\n  var path = value ? \"\".concat(property, \"/\").concat(value) : \"Binary_Property/\".concat(property);\n\n  try {\n    return require(\"regenerate-unicode-properties/\".concat(path, \".js\"));\n  } catch (exception) {\n    throw new Error(\"Failed to recognize value `\".concat(value, \"` for property \") + \"`\".concat(property, \"`.\"));\n  }\n};\n\nvar handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    var _property = 'General_Category';\n    var category = unicodeMatchPropertyValue(_property, value);\n    return getUnicodePropertyValueSet(_property, category);\n  } catch (exception) {} // It’s not a `General_Category` value, so check if it’s a binary\n  // property. Note: `unicodeMatchProperty` throws on invalid properties.\n\n\n  var property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\n\nvar getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {\n  var parts = value.split('=');\n  var firstPart = parts[0];\n  var set;\n\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    var property = unicodeMatchProperty(firstPart);\n\n    var _value = unicodeMatchPropertyValue(property, parts[1]);\n\n    set = getUnicodePropertyValueSet(property, _value);\n  }\n\n  if (isNegative) {\n    return UNICODE_SET.clone().remove(set);\n  }\n\n  return set.clone();\n}; // Given a range of code points, add any case-folded code points in that range\n// to a set.\n\n\nregenerate.prototype.iuAddRange = function (min, max) {\n  var $this = this;\n\n  do {\n    var folded = caseFold(min);\n\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nvar update = function update(item, pattern) {\n  var tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n\n  Object.assign(item, tree);\n};\n\nvar wrap = function wrap(tree, pattern) {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': \"(?:\".concat(pattern, \")\")\n  };\n};\n\nvar caseFold = function caseFold(codePoint) {\n  return iuMappings.get(codePoint) || false;\n};\n\nvar processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {\n  var set = regenerate();\n\n  var _iterator = _createForOfIteratorHelper(characterClassItem.body),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n\n      switch (item.type) {\n        case 'value':\n          set.add(item.codePoint);\n\n          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n            var folded = caseFold(item.codePoint);\n\n            if (folded) {\n              set.add(folded);\n            }\n          }\n\n          break;\n\n        case 'characterClassRange':\n          var min = item.min.codePoint;\n          var max = item.max.codePoint;\n          set.addRange(min, max);\n\n          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n            set.iuAddRange(min, max);\n          }\n\n          break;\n\n        case 'characterClassEscape':\n          set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));\n          break;\n\n        case 'unicodePropertyEscape':\n          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n          break;\n        // The `default` clause is only here as a safeguard; it should never be\n        // reached. Code coverage tools should ignore it.\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown term type: \".concat(item.type));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (characterClassItem.negative) {\n    update(characterClassItem, \"(?!\".concat(set.toString(regenerateOptions), \")[\\\\s\\\\S]\"));\n  } else {\n    update(characterClassItem, set.toString(regenerateOptions));\n  }\n\n  return characterClassItem;\n};\n\nvar updateNamedReference = function updateNamedReference(item, index) {\n  delete item.name;\n  item.matchIndex = index;\n};\n\nvar assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {\n  var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(\"Unknown group names: \".concat(unmatchedReferencesNames));\n  }\n};\n\nvar processTerm = function processTerm(item, regenerateOptions, groups) {\n  switch (item.type) {\n    case 'dot':\n      if (config.useDotAllFlag) {\n        break;\n      } else if (config.unicode) {\n        update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));\n      } else if (config.dotAll) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n\n      break;\n\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n\n    case 'unicodePropertyEscape':\n      if (config.unicodePropertyEscape) {\n        update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));\n      }\n\n      break;\n\n    case 'characterClassEscape':\n      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));\n      break;\n\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n\n      if (item.name && config.namedGroup) {\n        var name = item.name.value;\n\n        if (groups.names[name]) {\n          throw new Error(\"Multiple groups with the same name (\".concat(name, \") are not allowed.\"));\n        }\n\n        var index = groups.lastIndex;\n        delete item.name;\n        groups.names[name] = index;\n\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n\n        if (groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name].forEach(function (reference) {\n            updateNamedReference(reference, index);\n          });\n          delete groups.unmatchedReferences[name];\n        }\n      }\n\n    /* falls through */\n\n    case 'alternative':\n    case 'disjunction':\n    case 'quantifier':\n      item.body = item.body.map(function (term) {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'value':\n      var codePoint = item.codePoint;\n      var set = regenerate(codePoint);\n\n      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n        var folded = caseFold(codePoint);\n\n        if (folded) {\n          set.add(folded);\n        }\n      }\n\n      update(item, set.toString(regenerateOptions));\n      break;\n\n    case 'reference':\n      if (item.name) {\n        var _name = item.name.value;\n        var _index = groups.names[_name];\n\n        if (_index) {\n          updateNamedReference(item, _index);\n          break;\n        }\n\n        if (!groups.unmatchedReferences[_name]) {\n          groups.unmatchedReferences[_name] = [];\n        } // Keep track of references used before the corresponding group.\n\n\n        groups.unmatchedReferences[_name].push(item);\n      }\n\n      break;\n\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(\"Unknown term type: \".concat(item.type));\n  }\n\n  return item;\n};\n\nvar config = {\n  'ignoreCase': false,\n  'unicode': false,\n  'dotAll': false,\n  'useDotAllFlag': false,\n  'useUnicodeFlag': false,\n  'unicodePropertyEscape': false,\n  'namedGroup': false\n};\n\nvar rewritePattern = function rewritePattern(pattern, flags, options) {\n  config.unicode = flags && flags.includes('u');\n  var regjsparserFeatures = {\n    'unicodePropertyEscape': config.unicode,\n    'namedGroups': true,\n    'lookbehind': options && options.lookbehind\n  };\n  config.ignoreCase = flags && flags.includes('i');\n  var supportDotAllFlag = options && options.dotAllFlag;\n  config.dotAll = supportDotAllFlag && flags && flags.includes('s');\n  config.namedGroup = options && options.namedGroup;\n  config.useDotAllFlag = options && options.useDotAllFlag;\n  config.useUnicodeFlag = options && options.useUnicodeFlag;\n  config.unicodePropertyEscape = options && options.unicodePropertyEscape;\n\n  if (supportDotAllFlag && config.useDotAllFlag) {\n    throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n  }\n\n  var regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.unicode\n  };\n  var groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: index }\n    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\n  };\n  var tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.\n\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\n\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","prototype","iuAddRange","min","max","$this","folded","caseFold","add","update","item","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","processCharacterClass","characterClassItem","regenerateOptions","body","negative","toString","updateNamedReference","index","name","matchIndex","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","useDotAllFlag","unicodePropertyEscape","behavior","lastIndex","namedGroup","names","onNamedGroup","call","forEach","reference","map","term","push","rewritePattern","flags","options","includes","regjsparserFeatures","lookbehind","supportDotAllFlag","dotAllFlag","create","module","exports"],"sources":["E:/ReactJS/project-cursus/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a binary\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\treturn UNICODE_SET.clone().remove(set);\n\t}\n\treturn set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n\tconst set = regenerate();\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\t}\n\tif (characterClassItem.negative) {\n\t\tupdate(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`)\n\t} else {\n\t\tupdate(characterClassItem, set.toString(regenerateOptions));\n\t}\n\treturn characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n\tdelete item.name;\n\titem.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.useDotAllFlag) {\n\t\t\t\tbreak;\n\t\t\t} else if (config.unicode) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.dotAll).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.dotAll) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tif (config.unicodePropertyEscape) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\n\t\t\t\t\t\t.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name && config.namedGroup) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.names[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tdelete item.name;\n\n\t\t\t\tgroups.names[name] = index;\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\n\t\t\t\t\t\tupdateNamedReference(reference, index);\n\t\t\t\t\t});\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst index = groups.names[name];\n\t\t\t\tif (index) {\n\t\t\t\t\tupdateNamedReference(item, index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\n\t\t\t\t}\n\t\t\t\t// Keep track of references used before the corresponding group.\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'ignoreCase': false,\n\t'unicode': false,\n\t'dotAll': false,\n\t'useDotAllFlag': false,\n\t'useUnicodeFlag': false,\n\t'unicodePropertyEscape': false,\n\t'namedGroup': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n\tconfig.unicode = flags && flags.includes('u');\n\tconst regjsparserFeatures = {\n\t\t'unicodePropertyEscape': config.unicode,\n\t\t'namedGroups': true,\n\t\t'lookbehind': options && options.lookbehind\n\t};\n\tconfig.ignoreCase = flags && flags.includes('i');\n\tconst supportDotAllFlag = options && options.dotAllFlag;\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\n\tconfig.namedGroup = options && options.namedGroup;\n\tconfig.useDotAllFlag = options && options.useDotAllFlag;\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\n\tconfig.unicodePropertyEscape = options && options.unicodePropertyEscape;\n\tif (supportDotAllFlag && config.useDotAllFlag) {\n\t\tthrow new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n\t}\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.unicode\n\t};\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: index }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\t};\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}