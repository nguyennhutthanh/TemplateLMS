{"ast":null,"code":"import prism from '../prism/index.js';\nexport { default as Prism } from '../prism/index.js';\nimport theme from '../themes/duotoneDark';\nimport { Component } from 'react';\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism,\n  theme: theme\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function themeToDict(theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(Component);\n\nexport default Highlight;\nexport { defaultProps };","map":{"version":3,"names":["prism","default","Prism","theme","Component","defaultProps","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","newlineRe","normalizeEmptyLines","line","push","types","content","empty","appendTypes","add","typesSize","concat","normalizeTokens","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","i$1","pop","themeToDict","language","plain","base","create","themeDict","styles","reduce","themeEntry","languages","style","includes","forEach","accStyle","root","backgroundColor","objectWithoutProperties","exclude","k","indexOf","Highlight","this$1","args","len","props","undefined","prevTheme","prevLanguage","ref","className","rest$1","rest","output","getThemeDict","display","baseStyle","typeStyles","map","join","children","getStyleForToken","code","grammar","env","hooks","run","tokenize","__proto__","constructor","render","mixedTokens","getLineProps","getTokenProps"],"sources":["E:/ReactJS/project-cursus/node_modules/prism-react-renderer/dist/index.js"],"sourcesContent":["import prism from '../prism/index.js';\nexport { default as Prism } from '../prism/index.js';\nimport theme from '../themes/duotoneDark';\nimport { Component } from 'react';\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism,\n  theme: theme\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function (line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function (types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function (tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function (theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(Component);\n\nexport default Highlight;\nexport { defaultProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}