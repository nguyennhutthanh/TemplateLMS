{"ast":null,"code":"'use strict';\n\nconst generate = require('regjsgen').generate;\n\nconst parse = require('regjsparser').parse;\n\nconst regenerate = require('regenerate');\n\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\n\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nconst iuMappings = require('./data/iu-mappings.js');\n\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js'); // Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\n\n\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\n\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\n\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A, // Line Feed <LF>\n0x000D, // Carriage Return <CR>\n0x2028, // Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n\n  return ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = dotAll => {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;\n\n  try {\n    return require(`regenerate-unicode-properties/${path}.js`);\n  } catch (exception) {\n    throw new Error(`Failed to recognize value \\`${value}\\` for property ` + `\\`${property}\\`.`);\n  }\n};\n\nconst handleLoneUnicodePropertyNameOrValue = value => {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    const property = 'General_Category';\n    const category = unicodeMatchPropertyValue(property, value);\n    return getUnicodePropertyValueSet(property, category);\n  } catch (exception) {} // It’s not a `General_Category` value, so check if it’s a binary\n  // property. Note: `unicodeMatchProperty` throws on invalid properties.\n\n\n  const property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n  const parts = value.split('=');\n  const firstPart = parts[0];\n  let set;\n\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    const property = unicodeMatchProperty(firstPart);\n    const value = unicodeMatchPropertyValue(property, parts[1]);\n    set = getUnicodePropertyValueSet(property, value);\n  }\n\n  if (isNegative) {\n    return UNICODE_SET.clone().remove(set);\n  }\n\n  return set.clone();\n}; // Given a range of code points, add any case-folded code points in that range\n// to a set.\n\n\nregenerate.prototype.iuAddRange = function (min, max) {\n  const $this = this;\n\n  do {\n    const folded = caseFold(min);\n\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nconst update = (item, pattern) => {\n  let tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n\n  Object.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': `(?:${pattern})`\n  };\n};\n\nconst caseFold = codePoint => {\n  return iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n  const set = regenerate();\n\n  for (const item of characterClassItem.body) {\n    switch (item.type) {\n      case 'value':\n        set.add(item.codePoint);\n\n        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n          const folded = caseFold(item.codePoint);\n\n          if (folded) {\n            set.add(folded);\n          }\n        }\n\n        break;\n\n      case 'characterClassRange':\n        const min = item.min.codePoint;\n        const max = item.max.codePoint;\n        set.addRange(min, max);\n\n        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n          set.iuAddRange(min, max);\n        }\n\n        break;\n\n      case 'characterClassEscape':\n        set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));\n        break;\n\n      case 'unicodePropertyEscape':\n        set.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n        break;\n      // The `default` clause is only here as a safeguard; it should never be\n      // reached. Code coverage tools should ignore it.\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(`Unknown term type: ${item.type}`);\n    }\n  }\n\n  if (characterClassItem.negative) {\n    update(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`);\n  } else {\n    update(characterClassItem, set.toString(regenerateOptions));\n  }\n\n  return characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n  delete item.name;\n  item.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = groups => {\n  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n  }\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n  switch (item.type) {\n    case 'dot':\n      if (config.useDotAllFlag) {\n        break;\n      } else if (config.unicode) {\n        update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));\n      } else if (config.dotAll) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n\n      break;\n\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n\n    case 'unicodePropertyEscape':\n      if (config.unicodePropertyEscape) {\n        update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));\n      }\n\n      break;\n\n    case 'characterClassEscape':\n      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));\n      break;\n\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n\n      if (item.name && config.namedGroup) {\n        const name = item.name.value;\n\n        if (groups.names[name]) {\n          throw new Error(`Multiple groups with the same name (${name}) are not allowed.`);\n        }\n\n        const index = groups.lastIndex;\n        delete item.name;\n        groups.names[name] = index;\n\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n\n        if (groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name].forEach(reference => {\n            updateNamedReference(reference, index);\n          });\n          delete groups.unmatchedReferences[name];\n        }\n      }\n\n    /* falls through */\n\n    case 'alternative':\n    case 'disjunction':\n    case 'quantifier':\n      item.body = item.body.map(term => {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'value':\n      const codePoint = item.codePoint;\n      const set = regenerate(codePoint);\n\n      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n        const folded = caseFold(codePoint);\n\n        if (folded) {\n          set.add(folded);\n        }\n      }\n\n      update(item, set.toString(regenerateOptions));\n      break;\n\n    case 'reference':\n      if (item.name) {\n        const name = item.name.value;\n        const index = groups.names[name];\n\n        if (index) {\n          updateNamedReference(item, index);\n          break;\n        }\n\n        if (!groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name] = [];\n        } // Keep track of references used before the corresponding group.\n\n\n        groups.unmatchedReferences[name].push(item);\n      }\n\n      break;\n\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(`Unknown term type: ${item.type}`);\n  }\n\n  return item;\n};\n\nconst config = {\n  'ignoreCase': false,\n  'unicode': false,\n  'dotAll': false,\n  'useDotAllFlag': false,\n  'useUnicodeFlag': false,\n  'unicodePropertyEscape': false,\n  'namedGroup': false\n};\n\nconst rewritePattern = (pattern, flags, options) => {\n  config.unicode = flags && flags.includes('u');\n  const regjsparserFeatures = {\n    'unicodePropertyEscape': config.unicode,\n    'namedGroups': true,\n    'lookbehind': options && options.lookbehind\n  };\n  config.ignoreCase = flags && flags.includes('i');\n  const supportDotAllFlag = options && options.dotAllFlag;\n  config.dotAll = supportDotAllFlag && flags && flags.includes('s');\n  config.namedGroup = options && options.namedGroup;\n  config.useDotAllFlag = options && options.useDotAllFlag;\n  config.useUnicodeFlag = options && options.useUnicodeFlag;\n  config.unicodePropertyEscape = options && options.unicodePropertyEscape;\n\n  if (supportDotAllFlag && config.useDotAllFlag) {\n    throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n  }\n\n  const regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.unicode\n  };\n  const groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: index }\n    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\n  };\n  const tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.\n\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\n\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","prototype","iuAddRange","min","max","$this","folded","caseFold","add","update","item","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","processCharacterClass","characterClassItem","regenerateOptions","body","negative","toString","updateNamedReference","index","name","matchIndex","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","useDotAllFlag","unicodePropertyEscape","behavior","lastIndex","namedGroup","names","onNamedGroup","call","forEach","reference","map","term","push","rewritePattern","flags","options","includes","regjsparserFeatures","lookbehind","supportDotAllFlag","dotAllFlag","create","module","exports"],"sources":["E:/ReactJS/project-cursus/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a binary\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\treturn UNICODE_SET.clone().remove(set);\n\t}\n\treturn set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n\tconst set = regenerate();\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\t}\n\tif (characterClassItem.negative) {\n\t\tupdate(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`)\n\t} else {\n\t\tupdate(characterClassItem, set.toString(regenerateOptions));\n\t}\n\treturn characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n\tdelete item.name;\n\titem.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.useDotAllFlag) {\n\t\t\t\tbreak;\n\t\t\t} else if (config.unicode) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.dotAll).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.dotAll) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tif (config.unicodePropertyEscape) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\n\t\t\t\t\t\t.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name && config.namedGroup) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.names[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tdelete item.name;\n\n\t\t\t\tgroups.names[name] = index;\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\n\t\t\t\t\t\tupdateNamedReference(reference, index);\n\t\t\t\t\t});\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst index = groups.names[name];\n\t\t\t\tif (index) {\n\t\t\t\t\tupdateNamedReference(item, index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\n\t\t\t\t}\n\t\t\t\t// Keep track of references used before the corresponding group.\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'ignoreCase': false,\n\t'unicode': false,\n\t'dotAll': false,\n\t'useDotAllFlag': false,\n\t'useUnicodeFlag': false,\n\t'unicodePropertyEscape': false,\n\t'namedGroup': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n\tconfig.unicode = flags && flags.includes('u');\n\tconst regjsparserFeatures = {\n\t\t'unicodePropertyEscape': config.unicode,\n\t\t'namedGroups': true,\n\t\t'lookbehind': options && options.lookbehind\n\t};\n\tconfig.ignoreCase = flags && flags.includes('i');\n\tconst supportDotAllFlag = options && options.dotAllFlag;\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\n\tconfig.namedGroup = options && options.namedGroup;\n\tconfig.useDotAllFlag = options && options.useDotAllFlag;\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\n\tconfig.unicodePropertyEscape = options && options.unicodePropertyEscape;\n\tif (supportDotAllFlag && config.useDotAllFlag) {\n\t\tthrow new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n\t}\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.unicode\n\t};\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: index }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\t};\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}