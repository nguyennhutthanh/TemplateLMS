{"ast":null,"code":"import { encode } from 'sourcemap-codec';\n\nvar BitSet = function BitSet(arg) {\n  this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\n\nBitSet.prototype.add = function add(n) {\n  this.bits[n >> 5] |= 1 << (n & 31);\n};\n\nBitSet.prototype.has = function has(n) {\n  return !!(this.bits[n >> 5] & 1 << (n & 31));\n};\n\nvar Chunk = function Chunk(start, end, content) {\n  this.start = start;\n  this.end = end;\n  this.original = content;\n  this.intro = '';\n  this.outro = '';\n  this.content = content;\n  this.storeName = false;\n  this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n  Object.defineProperties(this, {\n    previous: {\n      writable: true,\n      value: null\n    },\n    next: {\n      writable: true,\n      value: null\n    }\n  });\n};\n\nChunk.prototype.appendLeft = function appendLeft(content) {\n  this.outro += content;\n};\n\nChunk.prototype.appendRight = function appendRight(content) {\n  this.intro = this.intro + content;\n};\n\nChunk.prototype.clone = function clone() {\n  var chunk = new Chunk(this.start, this.end, this.original);\n  chunk.intro = this.intro;\n  chunk.outro = this.outro;\n  chunk.content = this.content;\n  chunk.storeName = this.storeName;\n  chunk.edited = this.edited;\n  return chunk;\n};\n\nChunk.prototype.contains = function contains(index) {\n  return this.start < index && index < this.end;\n};\n\nChunk.prototype.eachNext = function eachNext(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.next;\n  }\n};\n\nChunk.prototype.eachPrevious = function eachPrevious(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.previous;\n  }\n};\n\nChunk.prototype.edit = function edit(content, storeName, contentOnly) {\n  this.content = content;\n\n  if (!contentOnly) {\n    this.intro = '';\n    this.outro = '';\n  }\n\n  this.storeName = storeName;\n  this.edited = true;\n  return this;\n};\n\nChunk.prototype.prependLeft = function prependLeft(content) {\n  this.outro = content + this.outro;\n};\n\nChunk.prototype.prependRight = function prependRight(content) {\n  this.intro = content + this.intro;\n};\n\nChunk.prototype.split = function split(index) {\n  var sliceIndex = index - this.start;\n  var originalBefore = this.original.slice(0, sliceIndex);\n  var originalAfter = this.original.slice(sliceIndex);\n  this.original = originalBefore;\n  var newChunk = new Chunk(index, this.end, originalAfter);\n  newChunk.outro = this.outro;\n  this.outro = '';\n  this.end = index;\n\n  if (this.edited) {\n    // TODO is this block necessary?...\n    newChunk.edit('', false);\n    this.content = '';\n  } else {\n    this.content = originalBefore;\n  }\n\n  newChunk.next = this.next;\n\n  if (newChunk.next) {\n    newChunk.next.previous = newChunk;\n  }\n\n  newChunk.previous = this;\n  this.next = newChunk;\n  return newChunk;\n};\n\nChunk.prototype.toString = function toString() {\n  return this.intro + this.content + this.outro;\n};\n\nChunk.prototype.trimEnd = function trimEnd(rx) {\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.start + trimmed.length).edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.intro = this.intro.replace(rx, '');\n\n    if (this.intro.length) {\n      return true;\n    }\n  }\n};\n\nChunk.prototype.trimStart = function trimStart(rx) {\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.end - trimmed.length);\n      this.edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.outro = this.outro.replace(rx, '');\n\n    if (this.outro.length) {\n      return true;\n    }\n  }\n};\n\nvar btoa = function () {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = function (str) {\n    return window.btoa(unescape(encodeURIComponent(str)));\n  };\n} else if (typeof Buffer === 'function') {\n  btoa = function (str) {\n    return Buffer.from(str, 'utf-8').toString('base64');\n  };\n}\n\nvar SourceMap = function SourceMap(properties) {\n  this.version = 3;\n  this.file = properties.file;\n  this.sources = properties.sources;\n  this.sourcesContent = properties.sourcesContent;\n  this.names = properties.names;\n  this.mappings = encode(properties.mappings);\n};\n\nSourceMap.prototype.toString = function toString() {\n  return JSON.stringify(this);\n};\n\nSourceMap.prototype.toUrl = function toUrl() {\n  return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\n\nfunction guessIndent(code) {\n  var lines = code.split('\\n');\n  var tabbed = lines.filter(function (line) {\n    return /^\\t+/.test(line);\n  });\n  var spaced = lines.filter(function (line) {\n    return /^ {2,}/.test(line);\n  });\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  var min = spaced.reduce(function (previous, current) {\n    var numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n  var fromParts = from.split(/[/\\\\]/);\n  var toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  if (fromParts.length) {\n    var i = fromParts.length;\n\n    while (i--) {\n      fromParts[i] = '..';\n    }\n  }\n\n  return fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n  var originalLines = source.split('\\n');\n  var lineOffsets = [];\n\n  for (var i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n\n  return function locate(index) {\n    var i = 0;\n    var j = lineOffsets.length;\n\n    while (i < j) {\n      var m = i + j >> 1;\n\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    var line = i - 1;\n    var column = index - lineOffsets[line];\n    return {\n      line: line,\n      column: column\n    };\n  };\n}\n\nvar Mappings = function Mappings(hires) {\n  this.hires = hires;\n  this.generatedCodeLine = 0;\n  this.generatedCodeColumn = 0;\n  this.raw = [];\n  this.rawSegments = this.raw[this.generatedCodeLine] = [];\n  this.pending = null;\n};\n\nMappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n  if (content.length) {\n    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n    if (nameIndex >= 0) {\n      segment.push(nameIndex);\n    }\n\n    this.rawSegments.push(segment);\n  } else if (this.pending) {\n    this.rawSegments.push(this.pending);\n  }\n\n  this.advance(content);\n  this.pending = null;\n};\n\nMappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n  var originalCharIndex = chunk.start;\n  var first = true;\n\n  while (originalCharIndex < chunk.end) {\n    if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n    }\n\n    if (original[originalCharIndex] === '\\n') {\n      loc.line += 1;\n      loc.column = 0;\n      this.generatedCodeLine += 1;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      this.generatedCodeColumn = 0;\n      first = true;\n    } else {\n      loc.column += 1;\n      this.generatedCodeColumn += 1;\n      first = false;\n    }\n\n    originalCharIndex += 1;\n  }\n\n  this.pending = null;\n};\n\nMappings.prototype.advance = function advance(str) {\n  if (!str) {\n    return;\n  }\n\n  var lines = str.split('\\n');\n\n  if (lines.length > 1) {\n    for (var i = 0; i < lines.length - 1; i++) {\n      this.generatedCodeLine++;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n    }\n\n    this.generatedCodeColumn = 0;\n  }\n\n  this.generatedCodeColumn += lines[lines.length - 1].length;\n};\n\nvar n = '\\n';\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\n\nvar MagicString = function MagicString(string, options) {\n  if (options === void 0) options = {};\n  var chunk = new Chunk(0, string.length, string);\n  Object.defineProperties(this, {\n    original: {\n      writable: true,\n      value: string\n    },\n    outro: {\n      writable: true,\n      value: ''\n    },\n    intro: {\n      writable: true,\n      value: ''\n    },\n    firstChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastSearchedChunk: {\n      writable: true,\n      value: chunk\n    },\n    byStart: {\n      writable: true,\n      value: {}\n    },\n    byEnd: {\n      writable: true,\n      value: {}\n    },\n    filename: {\n      writable: true,\n      value: options.filename\n    },\n    indentExclusionRanges: {\n      writable: true,\n      value: options.indentExclusionRanges\n    },\n    sourcemapLocations: {\n      writable: true,\n      value: new BitSet()\n    },\n    storedNames: {\n      writable: true,\n      value: {}\n    },\n    indentStr: {\n      writable: true,\n      value: guessIndent(string)\n    }\n  });\n  this.byStart[0] = chunk;\n  this.byEnd[string.length] = chunk;\n};\n\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n  this.sourcemapLocations.add(char);\n};\n\nMagicString.prototype.append = function append(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.outro += content;\n  return this;\n};\n\nMagicString.prototype.appendLeft = function appendLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.appendLeft(content);\n  } else {\n    this.intro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.appendRight = function appendRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.appendRight(content);\n  } else {\n    this.outro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.clone = function clone() {\n  var cloned = new MagicString(this.original, {\n    filename: this.filename\n  });\n  var originalChunk = this.firstChunk;\n  var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n  while (originalChunk) {\n    cloned.byStart[clonedChunk.start] = clonedChunk;\n    cloned.byEnd[clonedChunk.end] = clonedChunk;\n    var nextOriginalChunk = originalChunk.next;\n    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n    if (nextClonedChunk) {\n      clonedChunk.next = nextClonedChunk;\n      nextClonedChunk.previous = clonedChunk;\n      clonedChunk = nextClonedChunk;\n    }\n\n    originalChunk = nextOriginalChunk;\n  }\n\n  cloned.lastChunk = clonedChunk;\n\n  if (this.indentExclusionRanges) {\n    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n  }\n\n  cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n  cloned.intro = this.intro;\n  cloned.outro = this.outro;\n  return cloned;\n};\n\nMagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1$1 = this;\n  options = options || {};\n  var sourceIndex = 0;\n  var names = Object.keys(this.storedNames);\n  var mappings = new Mappings(options.hires);\n  var locate = getLocator(this.original);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.firstChunk.eachNext(function (chunk) {\n    var loc = locate(chunk.start);\n\n    if (chunk.intro.length) {\n      mappings.advance(chunk.intro);\n    }\n\n    if (chunk.edited) {\n      mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n    } else {\n      mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);\n    }\n\n    if (chunk.outro.length) {\n      mappings.advance(chunk.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n    sourcesContent: options.includeContent ? [this.original] : [null],\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nMagicString.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nMagicString.prototype.getIndentString = function getIndentString() {\n  return this.indentStr === null ? '\\t' : this.indentStr;\n};\n\nMagicString.prototype.indent = function indent(indentStr, options) {\n  var pattern = /^[^\\r\\n]/gm;\n\n  if (isObject(indentStr)) {\n    options = indentStr;\n    indentStr = undefined;\n  }\n\n  indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  options = options || {}; // Process exclusion ranges\n\n  var isExcluded = {};\n\n  if (options.exclude) {\n    var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n    exclusions.forEach(function (exclusion) {\n      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n        isExcluded[i] = true;\n      }\n    });\n  }\n\n  var shouldIndentNextCharacter = options.indentStart !== false;\n\n  var replacer = function (match) {\n    if (shouldIndentNextCharacter) {\n      return \"\" + indentStr + match;\n    }\n\n    shouldIndentNextCharacter = true;\n    return match;\n  };\n\n  this.intro = this.intro.replace(pattern, replacer);\n  var charIndex = 0;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    var end = chunk.end;\n\n    if (chunk.edited) {\n      if (!isExcluded[charIndex]) {\n        chunk.content = chunk.content.replace(pattern, replacer);\n\n        if (chunk.content.length) {\n          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n        }\n      }\n    } else {\n      charIndex = chunk.start;\n\n      while (charIndex < end) {\n        if (!isExcluded[charIndex]) {\n          var char = this.original[charIndex];\n\n          if (char === '\\n') {\n            shouldIndentNextCharacter = true;\n          } else if (char !== '\\r' && shouldIndentNextCharacter) {\n            shouldIndentNextCharacter = false;\n\n            if (charIndex === chunk.start) {\n              chunk.prependRight(indentStr);\n            } else {\n              this._splitChunk(chunk, charIndex);\n\n              chunk = chunk.next;\n              chunk.prependRight(indentStr);\n            }\n          }\n        }\n\n        charIndex += 1;\n      }\n    }\n\n    charIndex = chunk.end;\n    chunk = chunk.next;\n  }\n\n  this.outro = this.outro.replace(pattern, replacer);\n  return this;\n};\n\nMagicString.prototype.insert = function insert() {\n  throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\n\nMagicString.prototype.insertLeft = function insertLeft(index, content) {\n  if (!warned.insertLeft) {\n    console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n    warned.insertLeft = true;\n  }\n\n  return this.appendLeft(index, content);\n};\n\nMagicString.prototype.insertRight = function insertRight(index, content) {\n  if (!warned.insertRight) {\n    console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n    warned.insertRight = true;\n  }\n\n  return this.prependRight(index, content);\n};\n\nMagicString.prototype.move = function move(start, end, index) {\n  if (index >= start && index <= end) {\n    throw new Error('Cannot move a selection inside itself');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  this._split(index);\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n  var oldLeft = first.previous;\n  var oldRight = last.next;\n  var newRight = this.byStart[index];\n\n  if (!newRight && last === this.lastChunk) {\n    return this;\n  }\n\n  var newLeft = newRight ? newRight.previous : this.lastChunk;\n\n  if (oldLeft) {\n    oldLeft.next = oldRight;\n  }\n\n  if (oldRight) {\n    oldRight.previous = oldLeft;\n  }\n\n  if (newLeft) {\n    newLeft.next = first;\n  }\n\n  if (newRight) {\n    newRight.previous = last;\n  }\n\n  if (!first.previous) {\n    this.firstChunk = last.next;\n  }\n\n  if (!last.next) {\n    this.lastChunk = first.previous;\n    this.lastChunk.next = null;\n  }\n\n  first.previous = newLeft;\n  last.next = newRight || null;\n\n  if (!newLeft) {\n    this.firstChunk = first;\n  }\n\n  if (!newRight) {\n    this.lastChunk = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n  if (typeof content !== 'string') {\n    throw new TypeError('replacement content must be a string');\n  }\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (end > this.original.length) {\n    throw new Error('end is out of bounds');\n  }\n\n  if (start === end) {\n    throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  if (options === true) {\n    if (!warned.storeName) {\n      console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n      warned.storeName = true;\n    }\n\n    options = {\n      storeName: true\n    };\n  }\n\n  var storeName = options !== undefined ? options.storeName : false;\n  var contentOnly = options !== undefined ? options.contentOnly : false;\n\n  if (storeName) {\n    var original = this.original.slice(start, end);\n    Object.defineProperty(this.storedNames, original, {\n      writable: true,\n      value: true,\n      enumerable: true\n    });\n  }\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n\n  if (first) {\n    var chunk = first;\n\n    while (chunk !== last) {\n      if (chunk.next !== this.byStart[chunk.end]) {\n        throw new Error('Cannot overwrite across a split point');\n      }\n\n      chunk = chunk.next;\n      chunk.edit('', false);\n    }\n\n    first.edit(content, storeName, contentOnly);\n  } else {\n    // must be inserting at the end\n    var newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n    last.next = newChunk;\n    newChunk.previous = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prepend = function prepend(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.intro = content + this.intro;\n  return this;\n};\n\nMagicString.prototype.prependLeft = function prependLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.prependLeft(content);\n  } else {\n    this.intro = content + this.intro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prependRight = function prependRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.prependRight(content);\n  } else {\n    this.outro = content + this.outro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.remove = function remove(start, end) {\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (start === end) {\n    return this;\n  }\n\n  if (start < 0 || end > this.original.length) {\n    throw new Error('Character is out of bounds');\n  }\n\n  if (start > end) {\n    throw new Error('end must be greater than start');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  var chunk = this.byStart[start];\n\n  while (chunk) {\n    chunk.intro = '';\n    chunk.outro = '';\n    chunk.edit('');\n    chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n  }\n\n  return this;\n};\n\nMagicString.prototype.lastChar = function lastChar() {\n  if (this.outro.length) {\n    return this.outro[this.outro.length - 1];\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length) {\n      return chunk.outro[chunk.outro.length - 1];\n    }\n\n    if (chunk.content.length) {\n      return chunk.content[chunk.content.length - 1];\n    }\n\n    if (chunk.intro.length) {\n      return chunk.intro[chunk.intro.length - 1];\n    }\n  } while (chunk = chunk.previous);\n\n  if (this.intro.length) {\n    return this.intro[this.intro.length - 1];\n  }\n\n  return '';\n};\n\nMagicString.prototype.lastLine = function lastLine() {\n  var lineIndex = this.outro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.outro.substr(lineIndex + 1);\n  }\n\n  var lineStr = this.outro;\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length > 0) {\n      lineIndex = chunk.outro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.outro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.outro + lineStr;\n    }\n\n    if (chunk.content.length > 0) {\n      lineIndex = chunk.content.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.content.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.content + lineStr;\n    }\n\n    if (chunk.intro.length > 0) {\n      lineIndex = chunk.intro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.intro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.intro + lineStr;\n    }\n  } while (chunk = chunk.previous);\n\n  lineIndex = this.intro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.intro.substr(lineIndex + 1) + lineStr;\n  }\n\n  return this.intro + lineStr;\n};\n\nMagicString.prototype.slice = function slice(start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = this.original.length;\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  var result = ''; // find start chunk\n\n  var chunk = this.firstChunk;\n\n  while (chunk && (chunk.start > start || chunk.end <= start)) {\n    // found end chunk before start\n    if (chunk.start < end && chunk.end >= end) {\n      return result;\n    }\n\n    chunk = chunk.next;\n  }\n\n  if (chunk && chunk.edited && chunk.start !== start) {\n    throw new Error(\"Cannot use replaced character \" + start + \" as slice start anchor.\");\n  }\n\n  var startChunk = chunk;\n\n  while (chunk) {\n    if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n      result += chunk.intro;\n    }\n\n    var containsEnd = chunk.start < end && chunk.end >= end;\n\n    if (containsEnd && chunk.edited && chunk.end !== end) {\n      throw new Error(\"Cannot use replaced character \" + end + \" as slice end anchor.\");\n    }\n\n    var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n    var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n    result += chunk.content.slice(sliceStart, sliceEnd);\n\n    if (chunk.outro && (!containsEnd || chunk.end === end)) {\n      result += chunk.outro;\n    }\n\n    if (containsEnd) {\n      break;\n    }\n\n    chunk = chunk.next;\n  }\n\n  return result;\n}; // TODO deprecate this? not really very useful\n\n\nMagicString.prototype.snip = function snip(start, end) {\n  var clone = this.clone();\n  clone.remove(0, start);\n  clone.remove(end, clone.original.length);\n  return clone;\n};\n\nMagicString.prototype._split = function _split(index) {\n  if (this.byStart[index] || this.byEnd[index]) {\n    return;\n  }\n\n  var chunk = this.lastSearchedChunk;\n  var searchForward = index > chunk.end;\n\n  while (chunk) {\n    if (chunk.contains(index)) {\n      return this._splitChunk(chunk, index);\n    }\n\n    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n  }\n};\n\nMagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n  if (chunk.edited && chunk.content.length) {\n    // zero-length edited chunks are a special case (overlapping replacements)\n    var loc = getLocator(this.original)(index);\n    throw new Error(\"Cannot split a chunk that has already been edited (\" + loc.line + \":\" + loc.column + \" – \\\"\" + chunk.original + \"\\\")\");\n  }\n\n  var newChunk = chunk.split(index);\n  this.byEnd[index] = chunk;\n  this.byStart[index] = newChunk;\n  this.byEnd[newChunk.end] = newChunk;\n\n  if (chunk === this.lastChunk) {\n    this.lastChunk = newChunk;\n  }\n\n  this.lastSearchedChunk = chunk;\n  return true;\n};\n\nMagicString.prototype.toString = function toString() {\n  var str = this.intro;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    str += chunk.toString();\n    chunk = chunk.next;\n  }\n\n  return str + this.outro;\n};\n\nMagicString.prototype.isEmpty = function isEmpty() {\n  var chunk = this.firstChunk;\n\n  do {\n    if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {\n      return false;\n    }\n  } while (chunk = chunk.next);\n\n  return true;\n};\n\nMagicString.prototype.length = function length() {\n  var chunk = this.firstChunk;\n  var length = 0;\n\n  do {\n    length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n  } while (chunk = chunk.next);\n\n  return length;\n};\n\nMagicString.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nMagicString.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nMagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n    if (chunk.end !== end) {\n      if (this.lastChunk === chunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.previous;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimEnd = function trimEnd(charType) {\n  this.trimEndAborted(charType);\n  return this;\n};\n\nMagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var chunk = this.firstChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimStart(rx);\n\n    if (chunk.end !== end) {\n      // special case...\n      if (chunk === this.lastChunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.next;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimStart = function trimStart(charType) {\n  this.trimStartAborted(charType);\n  return this;\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar Bundle = function Bundle(options) {\n  if (options === void 0) options = {};\n  this.intro = options.intro || '';\n  this.separator = options.separator !== undefined ? options.separator : '\\n';\n  this.sources = [];\n  this.uniqueSources = [];\n  this.uniqueSourceIndexByFilename = {};\n};\n\nBundle.prototype.addSource = function addSource(source) {\n  if (source instanceof MagicString) {\n    return this.addSource({\n      content: source,\n      filename: source.filename,\n      separator: this.separator\n    });\n  }\n\n  if (!isObject(source) || !source.content) {\n    throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n  }\n\n  ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n    if (!hasOwnProp.call(source, option)) {\n      source[option] = source.content[option];\n    }\n  });\n\n  if (source.separator === undefined) {\n    // TODO there's a bunch of this sort of thing, needs cleaning up\n    source.separator = this.separator;\n  }\n\n  if (source.filename) {\n    if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n      this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n      this.uniqueSources.push({\n        filename: source.filename,\n        content: source.content.original\n      });\n    } else {\n      var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n      if (source.content.original !== uniqueSource.content) {\n        throw new Error(\"Illegal source: same filename (\" + source.filename + \"), different contents\");\n      }\n    }\n  }\n\n  this.sources.push(source);\n  return this;\n};\n\nBundle.prototype.append = function append(str, options) {\n  this.addSource({\n    content: new MagicString(str),\n    separator: options && options.separator || ''\n  });\n  return this;\n};\n\nBundle.prototype.clone = function clone() {\n  var bundle = new Bundle({\n    intro: this.intro,\n    separator: this.separator\n  });\n  this.sources.forEach(function (source) {\n    bundle.addSource({\n      filename: source.filename,\n      content: source.content.clone(),\n      separator: source.separator\n    });\n  });\n  return bundle;\n};\n\nBundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1$1 = this;\n  if (options === void 0) options = {};\n  var names = [];\n  this.sources.forEach(function (source) {\n    Object.keys(source.content.storedNames).forEach(function (name) {\n      if (!~names.indexOf(name)) {\n        names.push(name);\n      }\n    });\n  });\n  var mappings = new Mappings(options.hires);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.sources.forEach(function (source, i) {\n    if (i > 0) {\n      mappings.advance(this$1$1.separator);\n    }\n\n    var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;\n    var magicString = source.content;\n    var locate = getLocator(magicString.original);\n\n    if (magicString.intro) {\n      mappings.advance(magicString.intro);\n    }\n\n    magicString.firstChunk.eachNext(function (chunk) {\n      var loc = locate(chunk.start);\n\n      if (chunk.intro.length) {\n        mappings.advance(chunk.intro);\n      }\n\n      if (source.filename) {\n        if (chunk.edited) {\n          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n        } else {\n          mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n        }\n      } else {\n        mappings.advance(chunk.content);\n      }\n\n      if (chunk.outro.length) {\n        mappings.advance(chunk.outro);\n      }\n    });\n\n    if (magicString.outro) {\n      mappings.advance(magicString.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: this.uniqueSources.map(function (source) {\n      return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n    }),\n    sourcesContent: this.uniqueSources.map(function (source) {\n      return options.includeContent ? source.content : null;\n    }),\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nBundle.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nBundle.prototype.getIndentString = function getIndentString() {\n  var indentStringCounts = {};\n  this.sources.forEach(function (source) {\n    var indentStr = source.content.indentStr;\n\n    if (indentStr === null) {\n      return;\n    }\n\n    if (!indentStringCounts[indentStr]) {\n      indentStringCounts[indentStr] = 0;\n    }\n\n    indentStringCounts[indentStr] += 1;\n  });\n  return Object.keys(indentStringCounts).sort(function (a, b) {\n    return indentStringCounts[a] - indentStringCounts[b];\n  })[0] || '\\t';\n};\n\nBundle.prototype.indent = function indent(indentStr) {\n  var this$1$1 = this;\n\n  if (!arguments.length) {\n    indentStr = this.getIndentString();\n  }\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n  this.sources.forEach(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1$1.separator;\n    var indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n    source.content.indent(indentStr, {\n      exclude: source.indentExclusionRanges,\n      indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n    });\n    trailingNewline = source.content.lastChar() === '\\n';\n  });\n\n  if (this.intro) {\n    this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n      return index > 0 ? indentStr + match : match;\n    });\n  }\n\n  return this;\n};\n\nBundle.prototype.prepend = function prepend(str) {\n  this.intro = str + this.intro;\n  return this;\n};\n\nBundle.prototype.toString = function toString() {\n  var this$1$1 = this;\n  var body = this.sources.map(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1$1.separator;\n    var str = (i > 0 ? separator : '') + source.content.toString();\n    return str;\n  }).join('');\n  return this.intro + body;\n};\n\nBundle.prototype.isEmpty = function isEmpty() {\n  if (this.intro.length && this.intro.trim()) {\n    return false;\n  }\n\n  if (this.sources.some(function (source) {\n    return !source.content.isEmpty();\n  })) {\n    return false;\n  }\n\n  return true;\n};\n\nBundle.prototype.length = function length() {\n  return this.sources.reduce(function (length, source) {\n    return length + source.content.length();\n  }, this.intro.length);\n};\n\nBundle.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nBundle.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nBundle.prototype.trimStart = function trimStart(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (!this.intro) {\n    var source;\n    var i = 0;\n\n    do {\n      source = this.sources[i++];\n\n      if (!source) {\n        break;\n      }\n    } while (!source.content.trimStartAborted(charType));\n  }\n\n  return this;\n};\n\nBundle.prototype.trimEnd = function trimEnd(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  var source;\n  var i = this.sources.length - 1;\n\n  do {\n    source = this.sources[i--];\n\n    if (!source) {\n      this.intro = this.intro.replace(rx, '');\n      break;\n    }\n  } while (!source.content.trimEndAborted(charType));\n\n  return this;\n};\n\nexport { Bundle, SourceMap, MagicString as default };","map":{"version":3,"sources":["../src/BitSet.js","../src/Chunk.js","../src/SourceMap.js","../src/utils/guessIndent.js","../src/utils/getRelativePath.js","../src/utils/isObject.js","../src/utils/getLocator.js","../src/utils/Mappings.js","../src/MagicString.js","../src/Bundle.js"],"names":["const","let","this"],"mappings":"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","sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}